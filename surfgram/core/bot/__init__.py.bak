from surfgram_cli.utils import debugger
from surfgram_cli.enums import LevelsEnum
from surfgram.core.structures import APIObject
from surfgram.core.validator import Token
from surfgram.core.helpers import CamelCaseConverter
from surfgram.exceptions import BotError
import aiohttp
import asyncio
from typing import Dict, Optional, Any, Callable, Type




class Bot:
    """Enhanced bot class with reliable webhook support"""
    
    BASE_URL = "https://api.telegram.org/bot{token}/"
    
    def __init__(self, config: Type["BaseConfig"], debug_mode: bool = False):
        self.token = Token(config.get_token())
        self.listener = config.get_listener()()
        self._converter = CamelCaseConverter()
        self._session = None
        self._webhook_url = config.get_webhook()
        self._webhook_handler = None
        self._runner = None
        self._site = None

    async def _ensure_session(self):
        """Ensure HTTP session exists"""
        if self._session is None or self._session.closed:
            self._session = aiohttp.ClientSession()

    async def _make_request(self, method_name: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Make API request"""
        await self._ensure_session()
        url = self.BASE_URL.format(token=self.token) + self._converter.convert(method_name)
        
        async with self._session.post(url, json=params) as response:
            if response.status != 200:
                error_msg = f"API error {response.status}: {await response.text()}"
                debugger.log(error_msg, LevelsEnum.ERROR)
                raise BotError(error_msg)
            return await response.json()

    async def _setup_webhook(self):
        """Configure webhook with Telegram"""
        await self._make_request('setWebhook', {
            'url': self._webhook_url,
            'drop_pending_updates': True,
            'allowed_updates': ['message', 'callback_query']
        })

    async def _start_web_server(self):
        """Start local web server for webhook"""
        if not self._webhook_handler:
            self._webhook_handler = BaseWebhookHandler(self)
        
        app = web.Application()
        app.router.add_post('/', self._webhook_handler.process_request)
        
        self._runner = web.AppRunner(app)
        await self._runner.setup()
        self._site = web.TCPSite(self._runner, 'localhost', 8080)
        await self._site.start()
        await self._webhook_handler.start_processing()

    def set_webhook_handler(self, handler: WebhookHandler):
        """Set custom webhook handler"""
        if not isinstance(handler, WebhookHandler):
            raise TypeError("Handler must inherit from WebhookHandler")
        self._webhook_handler = handler

    def listen(self) -> None:
        """Main entry point"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            if self._webhook_url:
                loop.run_until_complete(self._setup_webhook())
                loop.run_until_complete(self._start_web_server())
                debugger.log(f"Webhook server ready at {self._webhook_url}", LevelsEnum.INFO)
                loop.run_forever()
            else:
                loop.run_until_complete(self.listener.listen(self))
        except KeyboardInterrupt:
            debugger.log("Shutting down...", LevelsEnum.INFO)
        finally:
            loop.run_until_complete(self._cleanup())
            loop.close()

    async def _cleanup(self):
        """Cleanup resources"""
        if self._site:
            await self._site.stop()
        if self._runner:
            await self._runner.cleanup()
        if self._session:
            await self._session.close()

    def __getattr__(self, method_name: str) -> Callable:
        """Dynamic API method handler"""
        async def method_handler(**kwargs):
            return await self._make_request(method_name, kwargs)
        return method_handler